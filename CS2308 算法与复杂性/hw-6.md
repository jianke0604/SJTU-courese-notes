# hw-6

$$
\textbf{秦啸涵\quad 521021910604}
$$

## 0427

### 1.平面有两组点，如何证明是否存在直线可以将这两组点分开

$\color{blue}{Solution:}$

如果存在一条直线，能够将这两组点分开，那么这两组点分居直线两侧，它们的凸包一定不相交。另一方面，如果这两组点的凸包不相交，我们也一定可以找到一条直线将这两个凸包分开，因此原问题等价于这两组点的凸包是否相交。

- 第一步，分别求出这两组点的凸包，使用Graham扫描算法，时间复杂度为$O(nlogn)$
- 第二步，判断两个凸包是否相交，使用扫描线算法，扫描线当前状态最多只需要记住4条边，因此可以在$O(n)$时间内完成



### 2.已知n个矩形，这些矩形的边都平行于坐标轴，1）求出这些矩形的交集；2）求出这些矩形能够覆盖的面积

$\color{blue}{Solution:}$

#### （1）求矩形的交集

任意两个矩形，如果有交集，则交集也一定是矩形。求两个矩形交集的时间复杂度为$O(1)$，之后再与其他矩形依次求交集即可，总的时间复杂度是$O(n)$

伪代码如下：

```c++
Input: R={[xi1,yi1,xi2,yi2]}
Output: [x1,y1,x2,y2]
[x1,y1,x2,y2]=random(R)   //从R中随机选一个矩形
for [xi1,yi1,xi2,yi2] in R:
	x1 = max(x1,xi1)      //左下角x坐标
    x2 = min(x2,xi2)	  //右上角x坐标
    y1 = max(y1,yi1)	  //左下角y坐标
    y2 = min(y2,yi2)	  //右上角y坐标
    if (y2<=y1 || x2<=x1)
        break
return [x1,y1,x2,y2]
```

#### (2)求矩形覆盖的面积

使用扫描线算法，事件列表为所有矩形的竖直边(其实就是端点x坐标)，扫描线状态为扫描线当前穿过的所有矩形。当扫描线状态发生变化时，计算当前事件点到上一个事件点之间的有效面积，并更新扫描线上的有效高度。具体而言，对所有矩形按两条竖直边的横坐标建立最小堆，之后按序遍历事件。由于处理竖直边计算有效高度需要一维区间查询，因此可以使用平衡树或者线段树来存储当前状态下的纵坐标，当扫描线状态改变时，`S += (x-x_last)*height`即可



### 3.有一组信封，已知每个信封的宽度和高度，当一个信封a的宽度和高度都比另一个信封b大的时候，信封b就可以放进信封a里，如同套娃一样。计算最多能有多少个信封组成一组“俄罗斯套娃”信封。注意：不允许旋转信封。

$\color{blue}{Solution:}$

思路：排序后动态规划

根据题目的要求，如果我们选择了k个信封，它们的的宽度依次为 $w_0, w_1, \cdots, w_{k-1}$,高度依次为$h_0, h_1, \cdots, h_{k-1}$，那么需要满足：
$$
\left\{
\begin{array}{}
w_0<w_1<\cdots<w_{k-1}\\
h_0<h_1<\cdots<h_{k-1}
\end{array}
\right.
$$
同时控制w和h两个维度并不是那么容易，因此我们考虑固定一个维度，再在另一个维度上进行选择。例如，我们固定w维度，那么我们将数组$\textit{envelopes}$中的所有信封按照w升序排序。这样一来，我们只要按照信封在数组中的出现顺序依次进行选取，就一定保证满足：

$$
w_0\le w_1\le \cdots\le w_{k-1}
$$
然而小于等于≤和小于<还是有区别的，当严格小于的时候，我们得到对应的序列$h_0,h_1,\cdots h_{k-1}$，问题就转化为在序列h中求**最长递增子序列**，这个问题使用动态规划可以非常容易地解决(dp[k]表示以h[k]结尾的最长递增子序列长度，遍历比较，$O(n^2)$时间复杂度内可解决)，但是当小于等于的时候，这样可能会得到错误的答案，例如$[1,1],[1,2],[1,3],[1,4]$,w都是1，如果按最长递增子序列的做法，我们得到答案为4，但是由于题目要求严格大于，所以正确答案为1。

关键点：对于同一个w，我们最多取一个信封，因此可以考虑对相同大小的w，将其对应的h按**降序排列**，这样以来，在最长递增子序列中，这些h至多出现一个，满足题目要求。

最终方案：对信封按w升序排序，相同的w对应的h按降序排序，对得到的h序列用动态规划求最长递增子序列

(直接使用动态规划求解最长递增子序列为$O(n^2)$，可以通过基于二分查找的动态规划优化到$O(nlogn)$)